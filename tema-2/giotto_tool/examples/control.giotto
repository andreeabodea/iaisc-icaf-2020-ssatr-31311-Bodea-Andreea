/*

 Copyright (c) 2001-2004 The Regents of the University of California.
 All rights reserved.

 Permission is hereby granted, without written agreement and without
 license or royalty fees, to use, copy, modify, and distribute this
 software and its documentation for any purpose, provided that the above
 copyright notice and the following two paragraphs appear in all copies
 of this software.

 IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY
 FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
 THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
 SUCH DAMAGE.

 THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
 PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
 CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
 ENHANCEMENTS, OR MODIFICATIONS.

 GIOTTO_COPYRIGHT_VERSION_2
 COPYRIGHTENDKEY
*/

/**

 This is a Giotto program with two tasks, two sensors, one actuator,
 and two Giotto modes.

 The program demonstrates a basic controller implementation.  It
 starts in the 'normal' mode by invoking the 'control' task with a
 period of 4s and the 'navigation' task with a period of 1s.  Try to
 change the periods and recompile using 'make compile'!

 The navigation task reads integer values from the 'random_sensor'
 port whose device driver 'c_connect_sensor_to_random_generator'
 generates random numbers between 1 and 20.  For visualization a
 new random number n will be printed by the device driver as n '*'
 characters on the screen.  The navigation task computes the average
 value of the sensor readings using a state variable.  All
 functionality is implemented by hand in C in the 'examples/fcode'
 subdirectory.

 The control task takes the output n of the navigation task and
 generates a string of n '-' characters.  Then this string is copied
 to the 'display_actuator' port whose device driver
 'c_connect_actuator_to_display' prints the string on the screen.

 The 'key_sensor' is 'true' whenever the return key on the keyboard is
 pressed.  This is done by the device driver
 'c_connect_sensor_to_return_key'.  Pressing the return key will
 trigger a mode switch from the normal mode to the 'degraded' mode and
 back.  The degraded mode is similar to the normal mode except for the
 frequency of the navigation task.  Upon mode switching the output
 port of the navigation task will be reset to 1 by the mode switch
 driver 'key_pressed'.

 Note that the Giotto compiler does perform a schedulability test
 based on the worst-case execution times given for each task.
 However, the worst-case execution times we use here are fictitious
 and only meant to demonstrate the schedulability test.

@author Christoph Kirsch
@version control.giotto,v 1.4 2004/09/29 01:04:21 cxh Exp
@since Giotto 1.0.1

*/

[ host HeliControl address 128.32.48.199:49153;
  host HeliNavigation address 128.32.171.237:49154;
  host HeliEmpty address 128.32.171.244:49155 ]

// Sensor ports

sensor

c_bool key_sensor uses c_connect_sensor_to_return_key [ host HeliNavigation ];
c_int random_sensor uses c_connect_sensor_to_random_generator [ host HeliNavigation ];

// Actuator port

actuator

c_string display_actuator uses c_connect_actuator_to_display [ host HeliControl ];

// Task output ports

output

c_string control_output := c_empty_string;
c_int navigation_output := c_one;

// Task declarations

task control(c_int control_input) output (control_output) state () [ wcet 4000 ] {
  schedule c_control_task(control_input, control_output)
}

task navigation(c_int sensor_input) output (navigation_output) state (c_int navigation_state := c_one) [ wcet 1000 ] {
  schedule c_navigation_task(sensor_input, navigation_state, navigation_output)
}

// Driver declarations

// Input driver for control task

driver control_driver(navigation_output) output (c_int control_input) {
  if c_true() then c_int_to_int(navigation_output, control_input)
}

// Input driver for navigation task

driver navigation_driver(random_sensor) output (c_int sensor_input) {
  if c_true() then c_int_to_int(random_sensor, sensor_input)
}

// Actuator driver

driver display_driver(control_output) output (c_string display_input) {
  if c_true() then c_string_to_string(control_output, display_input)
}

// Mode switch driver

driver key_pressed(key_sensor) output (c_int reset_state) {
  if c_key_pressed(key_sensor) then c_switch_mode(reset_state)
}

driver key_pressed2(key_sensor) output () {
  if c_key_pressed(key_sensor) then c_switch_mode()
}

// Mode declarations

start normal {

  mode normal(navigation_output) period 8000 {
    actfreq 1 do display_actuator(display_driver);

    [ host HeliNavigation; push (key_sensor) ]

    exitfreq 2 do degraded(key_pressed);

    taskfreq 1 do control(control_driver) [ host HeliControl; push (control_output) ];
    taskfreq 4 do navigation(navigation_driver) [ host HeliNavigation; push (navigation_output) ];
  }

  mode degraded(navigation_output) period 8000 {
    actfreq 1 do display_actuator(display_driver);

    [ host HeliNavigation; push (key_sensor) ]

    exitfreq 1 do normal(key_pressed);

    taskfreq 1 do control(control_driver) [ host HeliControl; push (control_output) ];
    taskfreq 2 do navigation(navigation_driver) [ host HeliNavigation; push (navigation_output) ];
  }
}
